'use strict';

var ganttChart = function(conf) {
    var self = {},
        chart, main, itemRects, xAxis, xScale, yAxis, yScale, zoom;

    self.items = null;
    self.lanes = null;
    self.renderTo = '#gantt_chart';
    self.sublanes = 1;

    self.isAutoResize = true;
    self.isEnableZoom = true;
    self.isShowXGrid = true;
    self.isShowYGrid = true;
    self.isShowLaneLabel = true;
    self.isTooltip = true;

    self.height = $(self.renderTo).height() || 480;
    self.width = $(self.renderTo).width() || 640;
    self.margin = {
        top: 20,
        right: 15,
        bottom: 20,
        left: 20
    };

    (function init() {
        copySameProp(self, conf);

        self.items = self.items || [];
        self.lanes = self.lanes || [];
        self.lanes.length = getLaneLength();

        build();
        enableZoom(self.isEnableZoom);
        setAutoResize(self.isAutoResize);
        setTooltip(self.isTooltip);
        showLaneLabel(self.isShowLaneLabel);
        showXGrid(self.isShowXGrid);
        showYGrid(self.isShowYGrid);
        redraw();
    })();

    function addItem(item) {
        self.items.push(item);
        onItemsChange();
    }

    function addItems(newItems) {
        self.items = self.items.concat(newItems);
        onItemsChange();
    }

    function build() {
        var laneLength = self.lanes.length,
            marginWidth = getMarginWidth(),
            marginHeight = getMarginHeight();

        chart = d3.select(self.renderTo)
            .append("svg")
            .attr("width", self.width)
            .attr("height", self.height)
            .attr("class", "chart");

        chart.append("defs").append("clipPath")
            .attr("id", "clip")
            .append("rect")
            .attr("width", marginWidth)
            .attr("height", marginHeight);

        main = chart.append("g")
            .attr("transform", "translate(" + self.margin.bottom + "," + self.margin.top + ")")
            .attr("width", marginWidth)
            .attr("height", marginHeight)
            .attr("class", "main");

        itemRects = main.append("g")
            .attr("clip-path", "url(#clip)");

        xScale = d3.time.scale()
            .domain(getTimeDomain())
            .range([0, marginWidth]);

        yScale = d3.scale.linear()
            .domain([0, laneLength])
            .range([0, marginHeight]);

        xAxis = d3.svg.axis()
            .scale(xScale)
            .orient('bottom')
            .ticks(5)

        yAxis = d3.svg.axis()
            .scale(yScale)
            .orient('left')
            .ticks(laneLength)
            .tickSize(-6, 0, 0)
            .tickFormat("");

        zoom = d3.behavior.zoom()
            .x(xScale);

        main.append('g')
            .attr('transform', 'translate(0,' + marginHeight + ')')
            .attr('class', 'main axis date')
            .call(xAxis)

        main.append('g')
            .attr('class', 'main axis lane')
            .call(yAxis);

        main.append('g')
            .attr('class', 'laneLabels');
    }

    function copySameProp(copyTo, copyFrom) {
        var p,
            toStr = Object.prototype.toString,
            ostr = ['object Object'];

        for (p in copyFrom) {
            if (copyTo.hasOwnProperty(p)) {
                if (toStr.call(copyFrom[p]) === ostr) {
                    copySameProp(copyTo[p], copyFrom[p]);
                }
                else {
                    copyTo[p] = copyFrom[p];
                }
            }
        }
    }

    function enableZoom(isEnableZoom) {
        if (isEnableZoom !== false) {
            zoom.on("zoom", redraw);
            chart.call(zoom);
        }
        else {
            zoom.on("zoom", null);
        }
        self.isEnableZoom = isEnableZoom;
    };

    function getLaneLength() {
        return (d3.max(self.items, function(d) { return d.lane }) + 1) || 0;
    }

    function getMarginWidth() {
        return self.width - self.margin.right - self.margin.left;
    }

    function getMarginHeight() {
        return self.height - self.margin.top - self.margin.bottom;
    }

    function getTimeDomain() {
        return [
            d3.min(self.items, function(d) { return d.start }),
            d3.max(self.items, function(d) { return d.end })
        ];
    }

    function onItemsChange() {
        self.lanes.length = getLaneLength();
        xScale.domain(getTimeDomain());
        yScale.domain([0, self.lanes.length]);
        zoom.x(xScale);
        redraw();
        setTooltip(self.isTooltip);
    }

    function redraw() {
        var itemHeight = getMarginHeight() / (self.lanes.length || 1) / (self.sublanes || 1),
            rects;

        main.select('g.main.axis.date').call(xAxis);
        main.select('g.main.axis.lane').call(yAxis);

        rects = itemRects.selectAll("rect")
            .data(self.items, function (d) { return d.id; })
            .attr("x", function (d) { return xScale(d.start); })
            .attr("y", function (d) {
                return (self.sublanes < 2) ? yScale(d.lane) : yScale(d.lane) + d.sublane*itemHeight;
            })
            .attr("width", function (d) { return xScale(d.end) - xScale(d.start); })
            .attr("height", function (d) { return itemHeight; });
        rects.enter().append("rect")
            .attr("class", function (d) { return d.class + ' main'; })
            .attr("x", function (d) { return xScale(d.start); })
            .attr("y", function (d) {
                return (self.sublanes < 2) ? yScale(d.lane) : yScale(d.lane) + d.sublane*itemHeight;
            })
            .attr("width", function (d) { return xScale(d.end) - xScale(d.start); })
            .attr("height", function (d) { return  itemHeight; })
            .attr("opacity", .75);
        rects.exit().remove();
    }

    function resize() {
        if (self.isAutoResize) {
            self.width = $(self.renderTo).width();
            self.height = $(self.renderTo).height();
        }
        var marginWidth = getMarginWidth(),
            marginHeight = getMarginHeight();

        xScale.range([0, marginWidth]);
        yScale.range([0, marginHeight]);
        chart.attr("width", self.width);
        chart.attr("height", self.height);
        chart.select('defs').select('clipPath').select('rect').attr("width", marginWidth);
        chart.select('defs').select('clipPath').select('rect').attr("height", marginWidth);
        main.attr("width", marginWidth);
        main.attr("height", marginHeight);

        main.select('g.main.axis.date')
            .attr('transform', 'translate(0,' + getMarginHeight() + ')');

        main.select('g.laneLabels')
            .selectAll(".laneText")
            .data(self.lanes)
            .attr("y", function(d, i) {return yScale(i + .5);})

        zoom.x(xScale);

        showXGrid(self.isShowYGrid);
        showYGrid(self.isShowYGrid);

        redraw();
    }

    function setAutoResize(isAutoResize) {
        d3.select(window).on('resize', (isAutoResize !== false) ? resize : null);
        self.isAutoResize = isAutoResize;
    }

    function setItems(items) {
        self.items = items;
        onItemsChange();
    }

    function setLanes(lanes) {
        self.lanes = lanes;
        self.lanes.length = getLaneLength() || self.lanes.length;
        showLaneLabel(!self.isShowLaneLabel);
        showLaneLabel(!self.isShowLaneLabel);
    }

    function setMargin(margin, isRedraw) {
        self.margin = margin;
        if (isRedraw === false) return;
        resize();
    }

    function setSize(width, height, isRedraw) {
        self.width = width || self.width;
        self.height = height || self.height;
        setAutoResize(false);
        if (isRedraw === false) return;
        resize();
    }

    function setSublanes(sublanes, isRedraw) {
        self.sublanes = sublanes;
        if (isRedraw === false) return;
        redraw();
    }

    function setTooltip(isTooltip) {
        self.isTooltip = isTooltip;
        if (isTooltip === false) return;

        $('svg.chart rect').on('click', function () {
            $('.gantt-tooltip').remove();
            if (this.classList[1] === 'main') {
                var d = this.__data__,
                    eOffset = $(this).offset(),
                    tooltip = '<div class="gantt-tooltip">' + d.tooltip + '</div>';
                $('body').append(tooltip);
                $('.gantt-tooltip').css({
                    'top': eOffset.top + this.height.baseVal.value + 5 + 'px',
                    'left': eOffset.left + 'px'
                });
            }
        });

        $(document).on('click', function (e) {
            if (!$(event.target).closest('svg rect').length) {
                $('.gantt-tooltip').remove();
            }
        });
    }

    function showLaneLabel(isShowLaneLabel) {
        self.isShowLaneLabel = isShowLaneLabel;
        if (isShowLaneLabel === false) {
            main.selectAll(".laneText").remove();
            return;
        }

        main.select('g.laneLabels').selectAll(".laneText")
            .data(self.lanes)
            .enter().append("text")
            .text(function(d) {return d;})
            .attr("x", -self.margin.right)
            .attr("y", function(d, i) {return yScale(i + .5);})
            .attr("dy", ".5ex")
            .attr("text-anchor", "start")
            .attr("class", "laneText");
    }

    function showXGrid(isShowXGrid, isRedraw) {
        var height = (isShowXGrid !== false) ? -getMarginHeight() : -6;
        xAxis.tickSize(height, 0, 0);
        self.isShowXGrid = isShowXGrid;
        if (isRedraw === false) return;
        redraw();
    }

    function showYGrid(isShowYGrid, isRedraw) {
        var width = (isShowYGrid !== false) ? -getMarginWidth() : -6;
        yAxis.tickSize(width, 0, 0);
        self.isShowYGrid = isShowYGrid;
        if (isRedraw === false) return;
        redraw();
    }


    return {
        addItem: addItem,
        addItems: addItems,
        enableZoom: enableZoom,
        getChart: function() { return main },
        getItems: function() { return self.items },
        getLanes: function() { return self.lanes },
        getMargin: function() { return self.margin },
        getSize: function() { return [self.width, self.height] },
        getSublanes: function() { return self.sublanes },
        getSvg: function() { return chart },
        getXAxis: function() { return xAxis },
        getXScale: function() { return xScale },
        getYAxis: function() { return yAxis },
        getYScale: function() { return yScale },
        isAutoResize: function() { return self.isAutoResize },
        isEnableZoom: function() { return self.isEnableZoom },
        isShowXGrid: function() { return self.isShowXGrid },
        isShowYGrid: function() { return self.isShowYGrid },
        isShowLaneLabel: function() { return self.isShowLaneLabel },
        isTooltip: function() { return self.isTooltip },
        renderTo: function() { return self.renderTo },
        redraw: redraw,
        setAutoResize: setAutoResize,
        setItems: setItems,
        setLanes: setLanes,
        setMargin: setMargin,
        setSize: setSize,
        setSublanes: setSublanes,
        setTooltip: setTooltip,
        showLaneLabel: showLaneLabel,
        showXGrid: showXGrid,
        showYGrid: showYGrid
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImdhbnR0LWNoYXJ0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2FudHQtY2hhcnQubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2FudHRDaGFydCA9IGZ1bmN0aW9uKGNvbmYpIHtcbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgICBjaGFydCwgbWFpbiwgaXRlbVJlY3RzLCB4QXhpcywgeFNjYWxlLCB5QXhpcywgeVNjYWxlLCB6b29tO1xuXG4gICAgc2VsZi5pdGVtcyA9IG51bGw7XG4gICAgc2VsZi5sYW5lcyA9IG51bGw7XG4gICAgc2VsZi5yZW5kZXJUbyA9ICcjZ2FudHRfY2hhcnQnO1xuICAgIHNlbGYuc3VibGFuZXMgPSAxO1xuXG4gICAgc2VsZi5pc0F1dG9SZXNpemUgPSB0cnVlO1xuICAgIHNlbGYuaXNFbmFibGVab29tID0gdHJ1ZTtcbiAgICBzZWxmLmlzU2hvd1hHcmlkID0gdHJ1ZTtcbiAgICBzZWxmLmlzU2hvd1lHcmlkID0gdHJ1ZTtcbiAgICBzZWxmLmlzU2hvd0xhbmVMYWJlbCA9IHRydWU7XG4gICAgc2VsZi5pc1Rvb2x0aXAgPSB0cnVlO1xuXG4gICAgc2VsZi5oZWlnaHQgPSAkKHNlbGYucmVuZGVyVG8pLmhlaWdodCgpIHx8IDQ4MDtcbiAgICBzZWxmLndpZHRoID0gJChzZWxmLnJlbmRlclRvKS53aWR0aCgpIHx8IDY0MDtcbiAgICBzZWxmLm1hcmdpbiA9IHtcbiAgICAgICAgdG9wOiAyMCxcbiAgICAgICAgcmlnaHQ6IDE1LFxuICAgICAgICBib3R0b206IDIwLFxuICAgICAgICBsZWZ0OiAyMFxuICAgIH07XG5cbiAgICAoZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgY29weVNhbWVQcm9wKHNlbGYsIGNvbmYpO1xuXG4gICAgICAgIHNlbGYuaXRlbXMgPSBzZWxmLml0ZW1zIHx8IFtdO1xuICAgICAgICBzZWxmLmxhbmVzID0gc2VsZi5sYW5lcyB8fCBbXTtcbiAgICAgICAgc2VsZi5sYW5lcy5sZW5ndGggPSBnZXRMYW5lTGVuZ3RoKCk7XG5cbiAgICAgICAgYnVpbGQoKTtcbiAgICAgICAgZW5hYmxlWm9vbShzZWxmLmlzRW5hYmxlWm9vbSk7XG4gICAgICAgIHNldEF1dG9SZXNpemUoc2VsZi5pc0F1dG9SZXNpemUpO1xuICAgICAgICBzZXRUb29sdGlwKHNlbGYuaXNUb29sdGlwKTtcbiAgICAgICAgc2hvd0xhbmVMYWJlbChzZWxmLmlzU2hvd0xhbmVMYWJlbCk7XG4gICAgICAgIHNob3dYR3JpZChzZWxmLmlzU2hvd1hHcmlkKTtcbiAgICAgICAgc2hvd1lHcmlkKHNlbGYuaXNTaG93WUdyaWQpO1xuICAgICAgICByZWRyYXcoKTtcbiAgICB9KSgpO1xuXG4gICAgZnVuY3Rpb24gYWRkSXRlbShpdGVtKSB7XG4gICAgICAgIHNlbGYuaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgb25JdGVtc0NoYW5nZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEl0ZW1zKG5ld0l0ZW1zKSB7XG4gICAgICAgIHNlbGYuaXRlbXMgPSBzZWxmLml0ZW1zLmNvbmNhdChuZXdJdGVtcyk7XG4gICAgICAgIG9uSXRlbXNDaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZCgpIHtcbiAgICAgICAgdmFyIGxhbmVMZW5ndGggPSBzZWxmLmxhbmVzLmxlbmd0aCxcbiAgICAgICAgICAgIG1hcmdpbldpZHRoID0gZ2V0TWFyZ2luV2lkdGgoKSxcbiAgICAgICAgICAgIG1hcmdpbkhlaWdodCA9IGdldE1hcmdpbkhlaWdodCgpO1xuXG4gICAgICAgIGNoYXJ0ID0gZDMuc2VsZWN0KHNlbGYucmVuZGVyVG8pXG4gICAgICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHNlbGYud2lkdGgpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBzZWxmLmhlaWdodClcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjaGFydFwiKTtcblxuICAgICAgICBjaGFydC5hcHBlbmQoXCJkZWZzXCIpLmFwcGVuZChcImNsaXBQYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwiY2xpcFwiKVxuICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgbWFyZ2luV2lkdGgpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBtYXJnaW5IZWlnaHQpO1xuXG4gICAgICAgIG1haW4gPSBjaGFydC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHNlbGYubWFyZ2luLmJvdHRvbSArIFwiLFwiICsgc2VsZi5tYXJnaW4udG9wICsgXCIpXCIpXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIG1hcmdpbldpZHRoKVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgbWFyZ2luSGVpZ2h0KVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm1haW5cIik7XG5cbiAgICAgICAgaXRlbVJlY3RzID0gbWFpbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsaXAtcGF0aFwiLCBcInVybCgjY2xpcClcIik7XG5cbiAgICAgICAgeFNjYWxlID0gZDMudGltZS5zY2FsZSgpXG4gICAgICAgICAgICAuZG9tYWluKGdldFRpbWVEb21haW4oKSlcbiAgICAgICAgICAgIC5yYW5nZShbMCwgbWFyZ2luV2lkdGhdKTtcblxuICAgICAgICB5U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgLmRvbWFpbihbMCwgbGFuZUxlbmd0aF0pXG4gICAgICAgICAgICAucmFuZ2UoWzAsIG1hcmdpbkhlaWdodF0pO1xuXG4gICAgICAgIHhBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAgICAgLnNjYWxlKHhTY2FsZSlcbiAgICAgICAgICAgIC5vcmllbnQoJ2JvdHRvbScpXG4gICAgICAgICAgICAudGlja3MoNSlcblxuICAgICAgICB5QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgIC5zY2FsZSh5U2NhbGUpXG4gICAgICAgICAgICAub3JpZW50KCdsZWZ0JylcbiAgICAgICAgICAgIC50aWNrcyhsYW5lTGVuZ3RoKVxuICAgICAgICAgICAgLnRpY2tTaXplKC02LCAwLCAwKVxuICAgICAgICAgICAgLnRpY2tGb3JtYXQoXCJcIik7XG5cbiAgICAgICAgem9vbSA9IGQzLmJlaGF2aW9yLnpvb20oKVxuICAgICAgICAgICAgLngoeFNjYWxlKTtcblxuICAgICAgICBtYWluLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyBtYXJnaW5IZWlnaHQgKyAnKScpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbWFpbiBheGlzIGRhdGUnKVxuICAgICAgICAgICAgLmNhbGwoeEF4aXMpXG5cbiAgICAgICAgbWFpbi5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ21haW4gYXhpcyBsYW5lJylcbiAgICAgICAgICAgIC5jYWxsKHlBeGlzKTtcblxuICAgICAgICBtYWluLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGFuZUxhYmVscycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvcHlTYW1lUHJvcChjb3B5VG8sIGNvcHlGcm9tKSB7XG4gICAgICAgIHZhciBwLFxuICAgICAgICAgICAgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgICAgICAgb3N0ciA9IFsnb2JqZWN0IE9iamVjdCddO1xuXG4gICAgICAgIGZvciAocCBpbiBjb3B5RnJvbSkge1xuICAgICAgICAgICAgaWYgKGNvcHlUby5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgICAgIGlmICh0b1N0ci5jYWxsKGNvcHlGcm9tW3BdKSA9PT0gb3N0cikge1xuICAgICAgICAgICAgICAgICAgICBjb3B5U2FtZVByb3AoY29weVRvW3BdLCBjb3B5RnJvbVtwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3B5VG9bcF0gPSBjb3B5RnJvbVtwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmFibGVab29tKGlzRW5hYmxlWm9vbSkge1xuICAgICAgICBpZiAoaXNFbmFibGVab29tICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgem9vbS5vbihcInpvb21cIiwgcmVkcmF3KTtcbiAgICAgICAgICAgIGNoYXJ0LmNhbGwoem9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB6b29tLm9uKFwiem9vbVwiLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmlzRW5hYmxlWm9vbSA9IGlzRW5hYmxlWm9vbTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0TGFuZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIChkMy5tYXgoc2VsZi5pdGVtcywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5sYW5lIH0pICsgMSkgfHwgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNYXJnaW5XaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYud2lkdGggLSBzZWxmLm1hcmdpbi5yaWdodCAtIHNlbGYubWFyZ2luLmxlZnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TWFyZ2luSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gc2VsZi5oZWlnaHQgLSBzZWxmLm1hcmdpbi50b3AgLSBzZWxmLm1hcmdpbi5ib3R0b207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VGltZURvbWFpbigpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGQzLm1pbihzZWxmLml0ZW1zLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnN0YXJ0IH0pLFxuICAgICAgICAgICAgZDMubWF4KHNlbGYuaXRlbXMsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuZW5kIH0pXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25JdGVtc0NoYW5nZSgpIHtcbiAgICAgICAgc2VsZi5sYW5lcy5sZW5ndGggPSBnZXRMYW5lTGVuZ3RoKCk7XG4gICAgICAgIHhTY2FsZS5kb21haW4oZ2V0VGltZURvbWFpbigpKTtcbiAgICAgICAgeVNjYWxlLmRvbWFpbihbMCwgc2VsZi5sYW5lcy5sZW5ndGhdKTtcbiAgICAgICAgem9vbS54KHhTY2FsZSk7XG4gICAgICAgIHJlZHJhdygpO1xuICAgICAgICBzZXRUb29sdGlwKHNlbGYuaXNUb29sdGlwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWRyYXcoKSB7XG4gICAgICAgIHZhciBpdGVtSGVpZ2h0ID0gZ2V0TWFyZ2luSGVpZ2h0KCkgLyAoc2VsZi5sYW5lcy5sZW5ndGggfHwgMSkgLyAoc2VsZi5zdWJsYW5lcyB8fCAxKSxcbiAgICAgICAgICAgIHJlY3RzO1xuXG4gICAgICAgIG1haW4uc2VsZWN0KCdnLm1haW4uYXhpcy5kYXRlJykuY2FsbCh4QXhpcyk7XG4gICAgICAgIG1haW4uc2VsZWN0KCdnLm1haW4uYXhpcy5sYW5lJykuY2FsbCh5QXhpcyk7XG5cbiAgICAgICAgcmVjdHMgPSBpdGVtUmVjdHMuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAgICAgLmRhdGEoc2VsZi5pdGVtcywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuaWQ7IH0pXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHhTY2FsZShkLnN0YXJ0KTsgfSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoc2VsZi5zdWJsYW5lcyA8IDIpID8geVNjYWxlKGQubGFuZSkgOiB5U2NhbGUoZC5sYW5lKSArIGQuc3VibGFuZSppdGVtSGVpZ2h0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHhTY2FsZShkLmVuZCkgLSB4U2NhbGUoZC5zdGFydCk7IH0pXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gaXRlbUhlaWdodDsgfSk7XG4gICAgICAgIHJlY3RzLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5jbGFzcyArICcgbWFpbic7IH0pXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHhTY2FsZShkLnN0YXJ0KTsgfSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoc2VsZi5zdWJsYW5lcyA8IDIpID8geVNjYWxlKGQubGFuZSkgOiB5U2NhbGUoZC5sYW5lKSArIGQuc3VibGFuZSppdGVtSGVpZ2h0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHhTY2FsZShkLmVuZCkgLSB4U2NhbGUoZC5zdGFydCk7IH0pXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gIGl0ZW1IZWlnaHQ7IH0pXG4gICAgICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwgLjc1KTtcbiAgICAgICAgcmVjdHMuZXhpdCgpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICAgICAgaWYgKHNlbGYuaXNBdXRvUmVzaXplKSB7XG4gICAgICAgICAgICBzZWxmLndpZHRoID0gJChzZWxmLnJlbmRlclRvKS53aWR0aCgpO1xuICAgICAgICAgICAgc2VsZi5oZWlnaHQgPSAkKHNlbGYucmVuZGVyVG8pLmhlaWdodCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJnaW5XaWR0aCA9IGdldE1hcmdpbldpZHRoKCksXG4gICAgICAgICAgICBtYXJnaW5IZWlnaHQgPSBnZXRNYXJnaW5IZWlnaHQoKTtcblxuICAgICAgICB4U2NhbGUucmFuZ2UoWzAsIG1hcmdpbldpZHRoXSk7XG4gICAgICAgIHlTY2FsZS5yYW5nZShbMCwgbWFyZ2luSGVpZ2h0XSk7XG4gICAgICAgIGNoYXJ0LmF0dHIoXCJ3aWR0aFwiLCBzZWxmLndpZHRoKTtcbiAgICAgICAgY2hhcnQuYXR0cihcImhlaWdodFwiLCBzZWxmLmhlaWdodCk7XG4gICAgICAgIGNoYXJ0LnNlbGVjdCgnZGVmcycpLnNlbGVjdCgnY2xpcFBhdGgnKS5zZWxlY3QoJ3JlY3QnKS5hdHRyKFwid2lkdGhcIiwgbWFyZ2luV2lkdGgpO1xuICAgICAgICBjaGFydC5zZWxlY3QoJ2RlZnMnKS5zZWxlY3QoJ2NsaXBQYXRoJykuc2VsZWN0KCdyZWN0JykuYXR0cihcImhlaWdodFwiLCBtYXJnaW5XaWR0aCk7XG4gICAgICAgIG1haW4uYXR0cihcIndpZHRoXCIsIG1hcmdpbldpZHRoKTtcbiAgICAgICAgbWFpbi5hdHRyKFwiaGVpZ2h0XCIsIG1hcmdpbkhlaWdodCk7XG5cbiAgICAgICAgbWFpbi5zZWxlY3QoJ2cubWFpbi5heGlzLmRhdGUnKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgZ2V0TWFyZ2luSGVpZ2h0KCkgKyAnKScpO1xuXG4gICAgICAgIG1haW4uc2VsZWN0KCdnLmxhbmVMYWJlbHMnKVxuICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5sYW5lVGV4dFwiKVxuICAgICAgICAgICAgLmRhdGEoc2VsZi5sYW5lcylcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBmdW5jdGlvbihkLCBpKSB7cmV0dXJuIHlTY2FsZShpICsgLjUpO30pXG5cbiAgICAgICAgem9vbS54KHhTY2FsZSk7XG5cbiAgICAgICAgc2hvd1hHcmlkKHNlbGYuaXNTaG93WUdyaWQpO1xuICAgICAgICBzaG93WUdyaWQoc2VsZi5pc1Nob3dZR3JpZCk7XG5cbiAgICAgICAgcmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0QXV0b1Jlc2l6ZShpc0F1dG9SZXNpemUpIHtcbiAgICAgICAgZDMuc2VsZWN0KHdpbmRvdykub24oJ3Jlc2l6ZScsIChpc0F1dG9SZXNpemUgIT09IGZhbHNlKSA/IHJlc2l6ZSA6IG51bGwpO1xuICAgICAgICBzZWxmLmlzQXV0b1Jlc2l6ZSA9IGlzQXV0b1Jlc2l6ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRJdGVtcyhpdGVtcykge1xuICAgICAgICBzZWxmLml0ZW1zID0gaXRlbXM7XG4gICAgICAgIG9uSXRlbXNDaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRMYW5lcyhsYW5lcykge1xuICAgICAgICBzZWxmLmxhbmVzID0gbGFuZXM7XG4gICAgICAgIHNlbGYubGFuZXMubGVuZ3RoID0gZ2V0TGFuZUxlbmd0aCgpIHx8IHNlbGYubGFuZXMubGVuZ3RoO1xuICAgICAgICBzaG93TGFuZUxhYmVsKCFzZWxmLmlzU2hvd0xhbmVMYWJlbCk7XG4gICAgICAgIHNob3dMYW5lTGFiZWwoIXNlbGYuaXNTaG93TGFuZUxhYmVsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRNYXJnaW4obWFyZ2luLCBpc1JlZHJhdykge1xuICAgICAgICBzZWxmLm1hcmdpbiA9IG1hcmdpbjtcbiAgICAgICAgaWYgKGlzUmVkcmF3ID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICByZXNpemUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRTaXplKHdpZHRoLCBoZWlnaHQsIGlzUmVkcmF3KSB7XG4gICAgICAgIHNlbGYud2lkdGggPSB3aWR0aCB8fCBzZWxmLndpZHRoO1xuICAgICAgICBzZWxmLmhlaWdodCA9IGhlaWdodCB8fCBzZWxmLmhlaWdodDtcbiAgICAgICAgc2V0QXV0b1Jlc2l6ZShmYWxzZSk7XG4gICAgICAgIGlmIChpc1JlZHJhdyA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgcmVzaXplKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0U3VibGFuZXMoc3VibGFuZXMsIGlzUmVkcmF3KSB7XG4gICAgICAgIHNlbGYuc3VibGFuZXMgPSBzdWJsYW5lcztcbiAgICAgICAgaWYgKGlzUmVkcmF3ID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICByZWRyYXcoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRUb29sdGlwKGlzVG9vbHRpcCkge1xuICAgICAgICBzZWxmLmlzVG9vbHRpcCA9IGlzVG9vbHRpcDtcbiAgICAgICAgaWYgKGlzVG9vbHRpcCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgICAkKCdzdmcuY2hhcnQgcmVjdCcpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQoJy5nYW50dC10b29sdGlwJykucmVtb3ZlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGFzc0xpc3RbMV0gPT09ICdtYWluJykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICAgICAgICAgICAgZU9mZnNldCA9ICQodGhpcykub2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXAgPSAnPGRpdiBjbGFzcz1cImdhbnR0LXRvb2x0aXBcIj4nICsgZC50b29sdGlwICsgJzwvZGl2Pic7XG4gICAgICAgICAgICAgICAgJCgnYm9keScpLmFwcGVuZCh0b29sdGlwKTtcbiAgICAgICAgICAgICAgICAkKCcuZ2FudHQtdG9vbHRpcCcpLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICd0b3AnOiBlT2Zmc2V0LnRvcCArIHRoaXMuaGVpZ2h0LmJhc2VWYWwudmFsdWUgKyA1ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgJ2xlZnQnOiBlT2Zmc2V0LmxlZnQgKyAncHgnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoISQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KCdzdmcgcmVjdCcpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICQoJy5nYW50dC10b29sdGlwJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3dMYW5lTGFiZWwoaXNTaG93TGFuZUxhYmVsKSB7XG4gICAgICAgIHNlbGYuaXNTaG93TGFuZUxhYmVsID0gaXNTaG93TGFuZUxhYmVsO1xuICAgICAgICBpZiAoaXNTaG93TGFuZUxhYmVsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbWFpbi5zZWxlY3RBbGwoXCIubGFuZVRleHRcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBtYWluLnNlbGVjdCgnZy5sYW5lTGFiZWxzJykuc2VsZWN0QWxsKFwiLmxhbmVUZXh0XCIpXG4gICAgICAgICAgICAuZGF0YShzZWxmLmxhbmVzKVxuICAgICAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkge3JldHVybiBkO30pXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgLXNlbGYubWFyZ2luLnJpZ2h0KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uKGQsIGkpIHtyZXR1cm4geVNjYWxlKGkgKyAuNSk7fSlcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCIuNWV4XCIpXG4gICAgICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwic3RhcnRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsYW5lVGV4dFwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG93WEdyaWQoaXNTaG93WEdyaWQsIGlzUmVkcmF3KSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSAoaXNTaG93WEdyaWQgIT09IGZhbHNlKSA/IC1nZXRNYXJnaW5IZWlnaHQoKSA6IC02O1xuICAgICAgICB4QXhpcy50aWNrU2l6ZShoZWlnaHQsIDAsIDApO1xuICAgICAgICBzZWxmLmlzU2hvd1hHcmlkID0gaXNTaG93WEdyaWQ7XG4gICAgICAgIGlmIChpc1JlZHJhdyA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgcmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvd1lHcmlkKGlzU2hvd1lHcmlkLCBpc1JlZHJhdykge1xuICAgICAgICB2YXIgd2lkdGggPSAoaXNTaG93WUdyaWQgIT09IGZhbHNlKSA/IC1nZXRNYXJnaW5XaWR0aCgpIDogLTY7XG4gICAgICAgIHlBeGlzLnRpY2tTaXplKHdpZHRoLCAwLCAwKTtcbiAgICAgICAgc2VsZi5pc1Nob3dZR3JpZCA9IGlzU2hvd1lHcmlkO1xuICAgICAgICBpZiAoaXNSZWRyYXcgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIHJlZHJhdygpO1xuICAgIH1cblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkSXRlbTogYWRkSXRlbSxcbiAgICAgICAgYWRkSXRlbXM6IGFkZEl0ZW1zLFxuICAgICAgICBlbmFibGVab29tOiBlbmFibGVab29tLFxuICAgICAgICBnZXRDaGFydDogZnVuY3Rpb24oKSB7IHJldHVybiBtYWluIH0sXG4gICAgICAgIGdldEl0ZW1zOiBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYuaXRlbXMgfSxcbiAgICAgICAgZ2V0TGFuZXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5sYW5lcyB9LFxuICAgICAgICBnZXRNYXJnaW46IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5tYXJnaW4gfSxcbiAgICAgICAgZ2V0U2l6ZTogZnVuY3Rpb24oKSB7IHJldHVybiBbc2VsZi53aWR0aCwgc2VsZi5oZWlnaHRdIH0sXG4gICAgICAgIGdldFN1YmxhbmVzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYuc3VibGFuZXMgfSxcbiAgICAgICAgZ2V0U3ZnOiBmdW5jdGlvbigpIHsgcmV0dXJuIGNoYXJ0IH0sXG4gICAgICAgIGdldFhBeGlzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHhBeGlzIH0sXG4gICAgICAgIGdldFhTY2FsZTogZnVuY3Rpb24oKSB7IHJldHVybiB4U2NhbGUgfSxcbiAgICAgICAgZ2V0WUF4aXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4geUF4aXMgfSxcbiAgICAgICAgZ2V0WVNjYWxlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHlTY2FsZSB9LFxuICAgICAgICBpc0F1dG9SZXNpemU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5pc0F1dG9SZXNpemUgfSxcbiAgICAgICAgaXNFbmFibGVab29tOiBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYuaXNFbmFibGVab29tIH0sXG4gICAgICAgIGlzU2hvd1hHcmlkOiBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYuaXNTaG93WEdyaWQgfSxcbiAgICAgICAgaXNTaG93WUdyaWQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5pc1Nob3dZR3JpZCB9LFxuICAgICAgICBpc1Nob3dMYW5lTGFiZWw6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5pc1Nob3dMYW5lTGFiZWwgfSxcbiAgICAgICAgaXNUb29sdGlwOiBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYuaXNUb29sdGlwIH0sXG4gICAgICAgIHJlbmRlclRvOiBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYucmVuZGVyVG8gfSxcbiAgICAgICAgcmVkcmF3OiByZWRyYXcsXG4gICAgICAgIHNldEF1dG9SZXNpemU6IHNldEF1dG9SZXNpemUsXG4gICAgICAgIHNldEl0ZW1zOiBzZXRJdGVtcyxcbiAgICAgICAgc2V0TGFuZXM6IHNldExhbmVzLFxuICAgICAgICBzZXRNYXJnaW46IHNldE1hcmdpbixcbiAgICAgICAgc2V0U2l6ZTogc2V0U2l6ZSxcbiAgICAgICAgc2V0U3VibGFuZXM6IHNldFN1YmxhbmVzLFxuICAgICAgICBzZXRUb29sdGlwOiBzZXRUb29sdGlwLFxuICAgICAgICBzaG93TGFuZUxhYmVsOiBzaG93TGFuZUxhYmVsLFxuICAgICAgICBzaG93WEdyaWQ6IHNob3dYR3JpZCxcbiAgICAgICAgc2hvd1lHcmlkOiBzaG93WUdyaWRcbiAgICB9XG59XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
