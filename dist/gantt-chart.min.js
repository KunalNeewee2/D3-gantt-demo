'use strict';

var ganttChart = function(conf) {
    var self = {},
        toStr = Object.prototype.toString,
        astr = "[object Array]",
        ostr = "[object Object]",
        chart, main, itemRects, tooltipDiv, xAxis, xScale, yAxis, yScale, zoom;

    self.items = null;
    self.lanes = null;
    self.renderTo = '#gantt_chart';
    self.sublanes = 1;

    self.isAutoResize = true;
    self.isEnableZoom = true;
    self.isShowXGrid = true;
    self.isShowYGrid = true;
    self.isShowLaneLabel = true;
    self.isShowTooltip = true;

    self.height = $(self.renderTo).height() || 480;
    self.width = $(self.renderTo).width() || 640;
    self.margin = {
        top: 20,
        right: 15,
        bottom: 20,
        left: 20
    };

    (function init() {
        copySameProp(self, conf);

        self.items = self.items || [];
        self.lanes = self.lanes || [];
        self.lanes.length = getLaneLength();

        build();
        enableZoom(self.isEnableZoom);
        autoresize(self.isAutoResize);
        showTooltip(self.isShowTooltip);
        showLaneLabel(self.isShowLaneLabel);
        showXGrid(self.isShowXGrid);
        showYGrid(self.isShowYGrid);
        redraw();
    })();

    function addItems(newItems) {
        var itemsType = toStr.call(newItems);
        if (itemsType !== astr && itemsType !== ostr) throwError('Expected object or array. Got: ' + itemsType);
        (itemsType === astr) ? self.items = self.items.concat(newItems) : self.items.push(newItems);
        onItemsChange();
    }

    function autoresize(isAutoResize) {
        if (!arguments.length) return self.isAutoResize;
        d3.select(window).on('resize', (isAutoResize !== false) ? resize : null);
        self.isAutoResize = isAutoResize;
    }

    function build() {
        var laneLength = self.lanes.length,
            marginWidth = getMarginWidth(),
            marginHeight = getMarginHeight();

        chart = d3.select(self.renderTo)
            .append("svg")
            .attr("width", self.width)
            .attr("height", self.height)
            .attr("class", "chart");

        chart.append("defs").append("clipPath")
            .attr("id", "clip")
            .append("rect")
            .attr("width", marginWidth)
            .attr("height", marginHeight);

        main = chart.append("g")
            .attr("transform", "translate(" + self.margin.bottom + "," + self.margin.top + ")")
            .attr("width", marginWidth)
            .attr("height", marginHeight)
            .attr("class", "main");

        itemRects = main.append("g")
            .attr("clip-path", "url(#clip)");

        tooltipDiv = d3.select("body").append("div")
            .attr("class", "gantt-tooltip")
            .style("opacity", 0);

        xScale = d3.time.scale()
            .domain(getTimeDomain())
            .range([0, marginWidth]);

        yScale = d3.scale.linear()
            .domain([0, laneLength])
            .range([0, marginHeight]);

        xAxis = d3.svg.axis()
            .scale(xScale)
            .orient('bottom')
            .ticks(5)

        yAxis = d3.svg.axis()
            .scale(yScale)
            .orient('left')
            .ticks(laneLength)
            .tickFormat("");

        zoom = d3.behavior.zoom()
            .x(xScale);

        main.append('g')
            .attr('transform', 'translate(0,' + marginHeight + ')')
            .attr('class', 'main axis date')
            .call(xAxis)

        main.append('g')
            .attr('class', 'main axis lane')
            .call(yAxis);

        main.append('g')
            .attr('class', 'laneLabels');

        chart.call(zoom);

        chart.on("click", function(d) {
            if (!self.isShowTooltip) return;
            if (!$(event.target).closest('svg rect').length) {
                tooltipDiv.transition()
                    .duration(500)
                    .style("opacity", 0);
            }
        });
    }

    function copySameProp(copyTo, copyFrom) {
        var p;

        for (p in copyFrom) {
            if (copyTo.hasOwnProperty(p)) {
                if (toStr.call(copyFrom[p]) === ostr) {
                    copySameProp(copyTo[p], copyFrom[p]);
                }
                else {
                    copyTo[p] = copyFrom[p];
                }
            }
        }
    }

    function enableZoom(isEnableZoom) {
        if (!arguments.length) return self.isEnableZoom;
        zoom.on("zoom", (isEnableZoom) ? redraw : null);
        self.isEnableZoom = isEnableZoom;
    }

    function getLaneLength() {
        return (d3.max(self.items, function(d) { return d.lane }) + 1) || 0;
    }

    function getMarginWidth() {
        return self.width - self.margin.right - self.margin.left;
    }

    function getMarginHeight() {
        return self.height - self.margin.top - self.margin.bottom;
    }

    function getTimeDomain() {
        return [
            d3.min(self.items, function(d) { return d.start }),
            d3.max(self.items, function(d) { return d.end })
        ];
    }

    function items(newItems) {
        var itemsType = toStr.call(newItems);

        if (!arguments.length) return self.items;
        if (itemsType !== astr) throwError('Expected array. Got: ' + itemsType);
        self.items = newItems;

        onItemsChange();
    }

    function lanes(newLanes) {
        var lanesType = toStr.call(newLanes);
        if (!arguments.length) return self.lanes;
        if (lanesType !== astr) throwError('Expected array. Got: ' + lanesType);
        self.lanes = newLanes;
        self.lanes.length = getLaneLength() || self.lanes.length;
        showLaneLabel(!self.isShowLaneLabel);
        showLaneLabel(!self.isShowLaneLabel);
    }

    function margin(newMargin) {
        var msg = "Some of the margin value is incorrect. All numbers should be type of number";
        if (!arguments.length) return self.margin;
        self.margin.top = (typeof newMargin.top === 'number') ? newMargin.top : throwError(msg);
        self.margin.right = (typeof newMargin.right === 'number') ? newMargin.right : throwError(msg);
        self.margin.bottom = (typeof newMargin.bottom === 'number') ? newMargin.bottom : throwError(msg);
        self.margin.left = (typeof newMargin.left === 'number') ? newMargin.left : throwError(msg);

        resize();
    }

    function onItemsChange() {
        var laneLength = getLaneLength();
        self.lanes.length = laneLength;
        xScale.domain(getTimeDomain());
        yAxis.ticks(laneLength);
        yScale.domain([0, laneLength]);
        zoom.x(xScale);
        redraw();
    }

    function redraw() {
        var itemHeight = getMarginHeight() / (self.lanes.length || 1) / (self.sublanes || 1),
            rects;

        rects = itemRects.selectAll("rect")
            .data(self.items, function (d) { return d.id; })
            .attr("x", function (d) { return xScale(d.start); })
            .attr("y", function (d) {
                return (self.sublanes < 2) ? yScale(d.lane) : yScale(d.lane) + d.sublane*itemHeight;
            })
            .attr("width", function (d) { return xScale(d.end) - xScale(d.start); })
            .attr("height", function (d) { return itemHeight; })
            .on("click", (self.isShowTooltip) ? tooltip : null);
        rects.enter().append("rect")
            .attr("class", function (d) { return d.class + ' main'; })
            .attr("x", function (d) { return xScale(d.start); })
            .attr("y", function (d) {
                return (self.sublanes < 2) ? yScale(d.lane) : yScale(d.lane) + d.sublane*itemHeight;
            })
            .attr("width", function (d) { return xScale(d.end) - xScale(d.start); })
            .attr("height", function (d) { return  itemHeight; })
            .attr("opacity", .75)
            .on("click", (self.isShowTooltip) ? tooltip : null);
        rects.exit().remove();

        main.select('g.main.axis.date').call(xAxis);
        main.select('g.main.axis.lane').call(yAxis);
    }

    function resize() {
        if (self.isAutoResize) {
            self.width = $(self.renderTo).width();
            self.height = $(self.renderTo).height();
        }
        var marginWidth = getMarginWidth(),
            marginHeight = getMarginHeight();

        xScale.range([0, marginWidth]);
        yScale.range([0, marginHeight]);
        chart.attr("width", self.width);
        chart.attr("height", self.height);
        chart.select('defs').select('clipPath').select('rect').attr("width", marginWidth);
        chart.select('defs').select('clipPath').select('rect').attr("height", marginWidth);
        main.attr("width", marginWidth);
        main.attr("height", marginHeight);

        main.select('g.main.axis.date')
            .attr('transform', 'translate(0,' + getMarginHeight() + ')');

        main.select('g.laneLabels')
            .selectAll(".laneText")
            .data(self.lanes)
            .attr("y", function(d, i) {return yScale(i + .5);})

        zoom.x(xScale);

        showXGrid(self.isShowYGrid);
        showYGrid(self.isShowYGrid);

        redraw();
    }

    function showLaneLabel(isShowLaneLabel) {
        if (!arguments.length) return self.isShowLaneLabel;
        self.isShowLaneLabel = isShowLaneLabel;
        if (isShowLaneLabel === false) {
            main.selectAll(".laneText").remove();
            return;
        }

        main.select('g.laneLabels').selectAll(".laneText")
            .data(self.lanes)
            .enter().append("text")
            .text(function(d) {return d;})
            .attr("x", -self.margin.right)
            .attr("y", function(d, i) {return yScale(i + .5);})
            .attr("dy", ".5ex")
            .attr("text-anchor", "start")
            .attr("class", "laneText");
    }

    function showTooltip(isShowTooltip) {
        if (!arguments.length) return self.isShowTooltip;
        self.isShowTooltip = isShowTooltip;
        redraw();
    }

    function tooltip(d) {
        tooltipDiv.transition()
            .duration(200)
            .style("opacity", .9);
        tooltipDiv.html((typeof d.tooltip === 'function') ? d.tooltip() : d.tooltip)
            .style("left", (d3.event.pageX) + "px")
            .style("top", (d3.event.pageY) + "px");
    }

    function throwError(msg) {
        throw TypeError(msg);
    }

    function showXGrid(isShowXGrid) {
        if (!arguments.length) return self.isShowXGrid;
        var height = (isShowXGrid !== false) ? -getMarginHeight() : -6;
        xAxis.tickSize(height, 0, 0);
        self.isShowXGrid = isShowXGrid;
        main.select('g.main.axis.date').call(xAxis);
    }

    function showYGrid(isShowYGrid) {
        if (!arguments.length) return self.isShowYGrid;
        var width = (isShowYGrid !== false) ? -getMarginWidth() : -6;
        yAxis.tickSize(width, 0, 0);
        self.isShowYGrid = isShowYGrid;
        main.select('g.main.axis.lane').call(yAxis);
    }

    function size(width, height) {
        if (!arguments.length) return [self.width, self.height];
        self.width = parseInt(width) || self.width;
        self.height = parseInt(height) || self.height;
        autoresize(false);
        resize();
    }

    function sublanes(newSublanes) {
        if (!arguments.length) return self.sublanes;
        self.sublanes = newSublanes;
        redraw();
    }

    return {
        addItems: addItems,
        autoresize: autoresize,
        enableZoom: enableZoom,
        chart: function() { return main },
        items: items,
        lanes: lanes,
        margin: margin,
        showLaneLabel: showLaneLabel,
        showTooltip: showTooltip,
        showXGrid: showXGrid,
        showYGrid: showYGrid,
        size: size,
        sublanes: sublanes,
        svg: function() { return chart },
        redraw: redraw,
        renderTo: function() { return self.renderTo },
        resize: resize,
        xAxis: function() { return xAxis },
        xScale: function() { return xScale },
        yScale: function() { return yScale },
        yAxis: function() { return yAxis },
        zoom: function() { return zoom },
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImdhbnR0LWNoYXJ0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdhbnR0LWNoYXJ0Lm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGdhbnR0Q2hhcnQgPSBmdW5jdGlvbihjb25mKSB7XG4gICAgdmFyIHNlbGYgPSB7fSxcbiAgICAgICAgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgICBhc3RyID0gXCJbb2JqZWN0IEFycmF5XVwiLFxuICAgICAgICBvc3RyID0gXCJbb2JqZWN0IE9iamVjdF1cIixcbiAgICAgICAgY2hhcnQsIG1haW4sIGl0ZW1SZWN0cywgdG9vbHRpcERpdiwgeEF4aXMsIHhTY2FsZSwgeUF4aXMsIHlTY2FsZSwgem9vbTtcblxuICAgIHNlbGYuaXRlbXMgPSBudWxsO1xuICAgIHNlbGYubGFuZXMgPSBudWxsO1xuICAgIHNlbGYucmVuZGVyVG8gPSAnI2dhbnR0X2NoYXJ0JztcbiAgICBzZWxmLnN1YmxhbmVzID0gMTtcblxuICAgIHNlbGYuaXNBdXRvUmVzaXplID0gdHJ1ZTtcbiAgICBzZWxmLmlzRW5hYmxlWm9vbSA9IHRydWU7XG4gICAgc2VsZi5pc1Nob3dYR3JpZCA9IHRydWU7XG4gICAgc2VsZi5pc1Nob3dZR3JpZCA9IHRydWU7XG4gICAgc2VsZi5pc1Nob3dMYW5lTGFiZWwgPSB0cnVlO1xuICAgIHNlbGYuaXNTaG93VG9vbHRpcCA9IHRydWU7XG5cbiAgICBzZWxmLmhlaWdodCA9ICQoc2VsZi5yZW5kZXJUbykuaGVpZ2h0KCkgfHwgNDgwO1xuICAgIHNlbGYud2lkdGggPSAkKHNlbGYucmVuZGVyVG8pLndpZHRoKCkgfHwgNjQwO1xuICAgIHNlbGYubWFyZ2luID0ge1xuICAgICAgICB0b3A6IDIwLFxuICAgICAgICByaWdodDogMTUsXG4gICAgICAgIGJvdHRvbTogMjAsXG4gICAgICAgIGxlZnQ6IDIwXG4gICAgfTtcblxuICAgIChmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICBjb3B5U2FtZVByb3Aoc2VsZiwgY29uZik7XG5cbiAgICAgICAgc2VsZi5pdGVtcyA9IHNlbGYuaXRlbXMgfHwgW107XG4gICAgICAgIHNlbGYubGFuZXMgPSBzZWxmLmxhbmVzIHx8IFtdO1xuICAgICAgICBzZWxmLmxhbmVzLmxlbmd0aCA9IGdldExhbmVMZW5ndGgoKTtcblxuICAgICAgICBidWlsZCgpO1xuICAgICAgICBlbmFibGVab29tKHNlbGYuaXNFbmFibGVab29tKTtcbiAgICAgICAgYXV0b3Jlc2l6ZShzZWxmLmlzQXV0b1Jlc2l6ZSk7XG4gICAgICAgIHNob3dUb29sdGlwKHNlbGYuaXNTaG93VG9vbHRpcCk7XG4gICAgICAgIHNob3dMYW5lTGFiZWwoc2VsZi5pc1Nob3dMYW5lTGFiZWwpO1xuICAgICAgICBzaG93WEdyaWQoc2VsZi5pc1Nob3dYR3JpZCk7XG4gICAgICAgIHNob3dZR3JpZChzZWxmLmlzU2hvd1lHcmlkKTtcbiAgICAgICAgcmVkcmF3KCk7XG4gICAgfSkoKTtcblxuICAgIGZ1bmN0aW9uIGFkZEl0ZW1zKG5ld0l0ZW1zKSB7XG4gICAgICAgIHZhciBpdGVtc1R5cGUgPSB0b1N0ci5jYWxsKG5ld0l0ZW1zKTtcbiAgICAgICAgaWYgKGl0ZW1zVHlwZSAhPT0gYXN0ciAmJiBpdGVtc1R5cGUgIT09IG9zdHIpIHRocm93RXJyb3IoJ0V4cGVjdGVkIG9iamVjdCBvciBhcnJheS4gR290OiAnICsgaXRlbXNUeXBlKTtcbiAgICAgICAgKGl0ZW1zVHlwZSA9PT0gYXN0cikgPyBzZWxmLml0ZW1zID0gc2VsZi5pdGVtcy5jb25jYXQobmV3SXRlbXMpIDogc2VsZi5pdGVtcy5wdXNoKG5ld0l0ZW1zKTtcbiAgICAgICAgb25JdGVtc0NoYW5nZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF1dG9yZXNpemUoaXNBdXRvUmVzaXplKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNlbGYuaXNBdXRvUmVzaXplO1xuICAgICAgICBkMy5zZWxlY3Qod2luZG93KS5vbigncmVzaXplJywgKGlzQXV0b1Jlc2l6ZSAhPT0gZmFsc2UpID8gcmVzaXplIDogbnVsbCk7XG4gICAgICAgIHNlbGYuaXNBdXRvUmVzaXplID0gaXNBdXRvUmVzaXplO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkKCkge1xuICAgICAgICB2YXIgbGFuZUxlbmd0aCA9IHNlbGYubGFuZXMubGVuZ3RoLFxuICAgICAgICAgICAgbWFyZ2luV2lkdGggPSBnZXRNYXJnaW5XaWR0aCgpLFxuICAgICAgICAgICAgbWFyZ2luSGVpZ2h0ID0gZ2V0TWFyZ2luSGVpZ2h0KCk7XG5cbiAgICAgICAgY2hhcnQgPSBkMy5zZWxlY3Qoc2VsZi5yZW5kZXJUbylcbiAgICAgICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgc2VsZi53aWR0aClcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHNlbGYuaGVpZ2h0KVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImNoYXJ0XCIpO1xuXG4gICAgICAgIGNoYXJ0LmFwcGVuZChcImRlZnNcIikuYXBwZW5kKFwiY2xpcFBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJjbGlwXCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBtYXJnaW5XaWR0aClcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIG1hcmdpbkhlaWdodCk7XG5cbiAgICAgICAgbWFpbiA9IGNoYXJ0LmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgc2VsZi5tYXJnaW4uYm90dG9tICsgXCIsXCIgKyBzZWxmLm1hcmdpbi50b3AgKyBcIilcIilcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgbWFyZ2luV2lkdGgpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBtYXJnaW5IZWlnaHQpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibWFpblwiKTtcblxuICAgICAgICBpdGVtUmVjdHMgPSBtYWluLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xpcC1wYXRoXCIsIFwidXJsKCNjbGlwKVwiKTtcblxuICAgICAgICB0b29sdGlwRGl2ID0gZDMuc2VsZWN0KFwiYm9keVwiKS5hcHBlbmQoXCJkaXZcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJnYW50dC10b29sdGlwXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuXG4gICAgICAgIHhTY2FsZSA9IGQzLnRpbWUuc2NhbGUoKVxuICAgICAgICAgICAgLmRvbWFpbihnZXRUaW1lRG9tYWluKCkpXG4gICAgICAgICAgICAucmFuZ2UoWzAsIG1hcmdpbldpZHRoXSk7XG5cbiAgICAgICAgeVNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4oWzAsIGxhbmVMZW5ndGhdKVxuICAgICAgICAgICAgLnJhbmdlKFswLCBtYXJnaW5IZWlnaHRdKTtcblxuICAgICAgICB4QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgIC5zY2FsZSh4U2NhbGUpXG4gICAgICAgICAgICAub3JpZW50KCdib3R0b20nKVxuICAgICAgICAgICAgLnRpY2tzKDUpXG5cbiAgICAgICAgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgICAgICAuc2NhbGUoeVNjYWxlKVxuICAgICAgICAgICAgLm9yaWVudCgnbGVmdCcpXG4gICAgICAgICAgICAudGlja3MobGFuZUxlbmd0aClcbiAgICAgICAgICAgIC50aWNrRm9ybWF0KFwiXCIpO1xuXG4gICAgICAgIHpvb20gPSBkMy5iZWhhdmlvci56b29tKClcbiAgICAgICAgICAgIC54KHhTY2FsZSk7XG5cbiAgICAgICAgbWFpbi5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgbWFyZ2luSGVpZ2h0ICsgJyknKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ21haW4gYXhpcyBkYXRlJylcbiAgICAgICAgICAgIC5jYWxsKHhBeGlzKVxuXG4gICAgICAgIG1haW4uYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdtYWluIGF4aXMgbGFuZScpXG4gICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG5cbiAgICAgICAgbWFpbi5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xhbmVMYWJlbHMnKTtcblxuICAgICAgICBjaGFydC5jYWxsKHpvb20pO1xuXG4gICAgICAgIGNoYXJ0Lm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzU2hvd1Rvb2x0aXApIHJldHVybjtcbiAgICAgICAgICAgIGlmICghJChldmVudC50YXJnZXQpLmNsb3Nlc3QoJ3N2ZyByZWN0JykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcERpdi50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwMClcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29weVNhbWVQcm9wKGNvcHlUbywgY29weUZyb20pIHtcbiAgICAgICAgdmFyIHA7XG5cbiAgICAgICAgZm9yIChwIGluIGNvcHlGcm9tKSB7XG4gICAgICAgICAgICBpZiAoY29weVRvLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvU3RyLmNhbGwoY29weUZyb21bcF0pID09PSBvc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlTYW1lUHJvcChjb3B5VG9bcF0sIGNvcHlGcm9tW3BdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlUb1twXSA9IGNvcHlGcm9tW3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuYWJsZVpvb20oaXNFbmFibGVab29tKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNlbGYuaXNFbmFibGVab29tO1xuICAgICAgICB6b29tLm9uKFwiem9vbVwiLCAoaXNFbmFibGVab29tKSA/IHJlZHJhdyA6IG51bGwpO1xuICAgICAgICBzZWxmLmlzRW5hYmxlWm9vbSA9IGlzRW5hYmxlWm9vbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRMYW5lTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gKGQzLm1heChzZWxmLml0ZW1zLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmxhbmUgfSkgKyAxKSB8fCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE1hcmdpbldpZHRoKCkge1xuICAgICAgICByZXR1cm4gc2VsZi53aWR0aCAtIHNlbGYubWFyZ2luLnJpZ2h0IC0gc2VsZi5tYXJnaW4ubGVmdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNYXJnaW5IZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmhlaWdodCAtIHNlbGYubWFyZ2luLnRvcCAtIHNlbGYubWFyZ2luLmJvdHRvbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUaW1lRG9tYWluKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZDMubWluKHNlbGYuaXRlbXMsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuc3RhcnQgfSksXG4gICAgICAgICAgICBkMy5tYXgoc2VsZi5pdGVtcywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5lbmQgfSlcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpdGVtcyhuZXdJdGVtcykge1xuICAgICAgICB2YXIgaXRlbXNUeXBlID0gdG9TdHIuY2FsbChuZXdJdGVtcyk7XG5cbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2VsZi5pdGVtcztcbiAgICAgICAgaWYgKGl0ZW1zVHlwZSAhPT0gYXN0cikgdGhyb3dFcnJvcignRXhwZWN0ZWQgYXJyYXkuIEdvdDogJyArIGl0ZW1zVHlwZSk7XG4gICAgICAgIHNlbGYuaXRlbXMgPSBuZXdJdGVtcztcblxuICAgICAgICBvbkl0ZW1zQ2hhbmdlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFuZXMobmV3TGFuZXMpIHtcbiAgICAgICAgdmFyIGxhbmVzVHlwZSA9IHRvU3RyLmNhbGwobmV3TGFuZXMpO1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzZWxmLmxhbmVzO1xuICAgICAgICBpZiAobGFuZXNUeXBlICE9PSBhc3RyKSB0aHJvd0Vycm9yKCdFeHBlY3RlZCBhcnJheS4gR290OiAnICsgbGFuZXNUeXBlKTtcbiAgICAgICAgc2VsZi5sYW5lcyA9IG5ld0xhbmVzO1xuICAgICAgICBzZWxmLmxhbmVzLmxlbmd0aCA9IGdldExhbmVMZW5ndGgoKSB8fCBzZWxmLmxhbmVzLmxlbmd0aDtcbiAgICAgICAgc2hvd0xhbmVMYWJlbCghc2VsZi5pc1Nob3dMYW5lTGFiZWwpO1xuICAgICAgICBzaG93TGFuZUxhYmVsKCFzZWxmLmlzU2hvd0xhbmVMYWJlbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFyZ2luKG5ld01hcmdpbikge1xuICAgICAgICB2YXIgbXNnID0gXCJTb21lIG9mIHRoZSBtYXJnaW4gdmFsdWUgaXMgaW5jb3JyZWN0LiBBbGwgbnVtYmVycyBzaG91bGQgYmUgdHlwZSBvZiBudW1iZXJcIjtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2VsZi5tYXJnaW47XG4gICAgICAgIHNlbGYubWFyZ2luLnRvcCA9ICh0eXBlb2YgbmV3TWFyZ2luLnRvcCA9PT0gJ251bWJlcicpID8gbmV3TWFyZ2luLnRvcCA6IHRocm93RXJyb3IobXNnKTtcbiAgICAgICAgc2VsZi5tYXJnaW4ucmlnaHQgPSAodHlwZW9mIG5ld01hcmdpbi5yaWdodCA9PT0gJ251bWJlcicpID8gbmV3TWFyZ2luLnJpZ2h0IDogdGhyb3dFcnJvcihtc2cpO1xuICAgICAgICBzZWxmLm1hcmdpbi5ib3R0b20gPSAodHlwZW9mIG5ld01hcmdpbi5ib3R0b20gPT09ICdudW1iZXInKSA/IG5ld01hcmdpbi5ib3R0b20gOiB0aHJvd0Vycm9yKG1zZyk7XG4gICAgICAgIHNlbGYubWFyZ2luLmxlZnQgPSAodHlwZW9mIG5ld01hcmdpbi5sZWZ0ID09PSAnbnVtYmVyJykgPyBuZXdNYXJnaW4ubGVmdCA6IHRocm93RXJyb3IobXNnKTtcblxuICAgICAgICByZXNpemUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkl0ZW1zQ2hhbmdlKCkge1xuICAgICAgICB2YXIgbGFuZUxlbmd0aCA9IGdldExhbmVMZW5ndGgoKTtcbiAgICAgICAgc2VsZi5sYW5lcy5sZW5ndGggPSBsYW5lTGVuZ3RoO1xuICAgICAgICB4U2NhbGUuZG9tYWluKGdldFRpbWVEb21haW4oKSk7XG4gICAgICAgIHlBeGlzLnRpY2tzKGxhbmVMZW5ndGgpO1xuICAgICAgICB5U2NhbGUuZG9tYWluKFswLCBsYW5lTGVuZ3RoXSk7XG4gICAgICAgIHpvb20ueCh4U2NhbGUpO1xuICAgICAgICByZWRyYXcoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWRyYXcoKSB7XG4gICAgICAgIHZhciBpdGVtSGVpZ2h0ID0gZ2V0TWFyZ2luSGVpZ2h0KCkgLyAoc2VsZi5sYW5lcy5sZW5ndGggfHwgMSkgLyAoc2VsZi5zdWJsYW5lcyB8fCAxKSxcbiAgICAgICAgICAgIHJlY3RzO1xuXG4gICAgICAgIHJlY3RzID0gaXRlbVJlY3RzLnNlbGVjdEFsbChcInJlY3RcIilcbiAgICAgICAgICAgIC5kYXRhKHNlbGYuaXRlbXMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmlkOyB9KVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4U2NhbGUoZC5zdGFydCk7IH0pXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNlbGYuc3VibGFuZXMgPCAyKSA/IHlTY2FsZShkLmxhbmUpIDogeVNjYWxlKGQubGFuZSkgKyBkLnN1YmxhbmUqaXRlbUhlaWdodDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4U2NhbGUoZC5lbmQpIC0geFNjYWxlKGQuc3RhcnQpOyB9KVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGl0ZW1IZWlnaHQ7IH0pXG4gICAgICAgICAgICAub24oXCJjbGlja1wiLCAoc2VsZi5pc1Nob3dUb29sdGlwKSA/IHRvb2x0aXAgOiBudWxsKTtcbiAgICAgICAgcmVjdHMuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmNsYXNzICsgJyBtYWluJzsgfSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geFNjYWxlKGQuc3RhcnQpOyB9KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzZWxmLnN1YmxhbmVzIDwgMikgPyB5U2NhbGUoZC5sYW5lKSA6IHlTY2FsZShkLmxhbmUpICsgZC5zdWJsYW5lKml0ZW1IZWlnaHQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geFNjYWxlKGQuZW5kKSAtIHhTY2FsZShkLnN0YXJ0KTsgfSlcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGZ1bmN0aW9uIChkKSB7IHJldHVybiAgaXRlbUhlaWdodDsgfSlcbiAgICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLCAuNzUpXG4gICAgICAgICAgICAub24oXCJjbGlja1wiLCAoc2VsZi5pc1Nob3dUb29sdGlwKSA/IHRvb2x0aXAgOiBudWxsKTtcbiAgICAgICAgcmVjdHMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIG1haW4uc2VsZWN0KCdnLm1haW4uYXhpcy5kYXRlJykuY2FsbCh4QXhpcyk7XG4gICAgICAgIG1haW4uc2VsZWN0KCdnLm1haW4uYXhpcy5sYW5lJykuY2FsbCh5QXhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgICBpZiAoc2VsZi5pc0F1dG9SZXNpemUpIHtcbiAgICAgICAgICAgIHNlbGYud2lkdGggPSAkKHNlbGYucmVuZGVyVG8pLndpZHRoKCk7XG4gICAgICAgICAgICBzZWxmLmhlaWdodCA9ICQoc2VsZi5yZW5kZXJUbykuaGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmdpbldpZHRoID0gZ2V0TWFyZ2luV2lkdGgoKSxcbiAgICAgICAgICAgIG1hcmdpbkhlaWdodCA9IGdldE1hcmdpbkhlaWdodCgpO1xuXG4gICAgICAgIHhTY2FsZS5yYW5nZShbMCwgbWFyZ2luV2lkdGhdKTtcbiAgICAgICAgeVNjYWxlLnJhbmdlKFswLCBtYXJnaW5IZWlnaHRdKTtcbiAgICAgICAgY2hhcnQuYXR0cihcIndpZHRoXCIsIHNlbGYud2lkdGgpO1xuICAgICAgICBjaGFydC5hdHRyKFwiaGVpZ2h0XCIsIHNlbGYuaGVpZ2h0KTtcbiAgICAgICAgY2hhcnQuc2VsZWN0KCdkZWZzJykuc2VsZWN0KCdjbGlwUGF0aCcpLnNlbGVjdCgncmVjdCcpLmF0dHIoXCJ3aWR0aFwiLCBtYXJnaW5XaWR0aCk7XG4gICAgICAgIGNoYXJ0LnNlbGVjdCgnZGVmcycpLnNlbGVjdCgnY2xpcFBhdGgnKS5zZWxlY3QoJ3JlY3QnKS5hdHRyKFwiaGVpZ2h0XCIsIG1hcmdpbldpZHRoKTtcbiAgICAgICAgbWFpbi5hdHRyKFwid2lkdGhcIiwgbWFyZ2luV2lkdGgpO1xuICAgICAgICBtYWluLmF0dHIoXCJoZWlnaHRcIiwgbWFyZ2luSGVpZ2h0KTtcblxuICAgICAgICBtYWluLnNlbGVjdCgnZy5tYWluLmF4aXMuZGF0ZScpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyBnZXRNYXJnaW5IZWlnaHQoKSArICcpJyk7XG5cbiAgICAgICAgbWFpbi5zZWxlY3QoJ2cubGFuZUxhYmVscycpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmxhbmVUZXh0XCIpXG4gICAgICAgICAgICAuZGF0YShzZWxmLmxhbmVzKVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uKGQsIGkpIHtyZXR1cm4geVNjYWxlKGkgKyAuNSk7fSlcblxuICAgICAgICB6b29tLngoeFNjYWxlKTtcblxuICAgICAgICBzaG93WEdyaWQoc2VsZi5pc1Nob3dZR3JpZCk7XG4gICAgICAgIHNob3dZR3JpZChzZWxmLmlzU2hvd1lHcmlkKTtcblxuICAgICAgICByZWRyYXcoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG93TGFuZUxhYmVsKGlzU2hvd0xhbmVMYWJlbCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzZWxmLmlzU2hvd0xhbmVMYWJlbDtcbiAgICAgICAgc2VsZi5pc1Nob3dMYW5lTGFiZWwgPSBpc1Nob3dMYW5lTGFiZWw7XG4gICAgICAgIGlmIChpc1Nob3dMYW5lTGFiZWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBtYWluLnNlbGVjdEFsbChcIi5sYW5lVGV4dFwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1haW4uc2VsZWN0KCdnLmxhbmVMYWJlbHMnKS5zZWxlY3RBbGwoXCIubGFuZVRleHRcIilcbiAgICAgICAgICAgIC5kYXRhKHNlbGYubGFuZXMpXG4gICAgICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7cmV0dXJuIGQ7fSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAtc2VsZi5tYXJnaW4ucmlnaHQpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgZnVuY3Rpb24oZCwgaSkge3JldHVybiB5U2NhbGUoaSArIC41KTt9KVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi41ZXhcIilcbiAgICAgICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJzdGFydFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxhbmVUZXh0XCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwKGlzU2hvd1Rvb2x0aXApIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2VsZi5pc1Nob3dUb29sdGlwO1xuICAgICAgICBzZWxmLmlzU2hvd1Rvb2x0aXAgPSBpc1Nob3dUb29sdGlwO1xuICAgICAgICByZWRyYXcoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b29sdGlwKGQpIHtcbiAgICAgICAgdG9vbHRpcERpdi50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbigyMDApXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIC45KTtcbiAgICAgICAgdG9vbHRpcERpdi5odG1sKCh0eXBlb2YgZC50b29sdGlwID09PSAnZnVuY3Rpb24nKSA/IGQudG9vbHRpcCgpIDogZC50b29sdGlwKVxuICAgICAgICAgICAgLnN0eWxlKFwibGVmdFwiLCAoZDMuZXZlbnQucGFnZVgpICsgXCJweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidG9wXCIsIChkMy5ldmVudC5wYWdlWSkgKyBcInB4XCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRocm93RXJyb3IobXNnKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcihtc2cpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3dYR3JpZChpc1Nob3dYR3JpZCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzZWxmLmlzU2hvd1hHcmlkO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gKGlzU2hvd1hHcmlkICE9PSBmYWxzZSkgPyAtZ2V0TWFyZ2luSGVpZ2h0KCkgOiAtNjtcbiAgICAgICAgeEF4aXMudGlja1NpemUoaGVpZ2h0LCAwLCAwKTtcbiAgICAgICAgc2VsZi5pc1Nob3dYR3JpZCA9IGlzU2hvd1hHcmlkO1xuICAgICAgICBtYWluLnNlbGVjdCgnZy5tYWluLmF4aXMuZGF0ZScpLmNhbGwoeEF4aXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3dZR3JpZChpc1Nob3dZR3JpZCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzZWxmLmlzU2hvd1lHcmlkO1xuICAgICAgICB2YXIgd2lkdGggPSAoaXNTaG93WUdyaWQgIT09IGZhbHNlKSA/IC1nZXRNYXJnaW5XaWR0aCgpIDogLTY7XG4gICAgICAgIHlBeGlzLnRpY2tTaXplKHdpZHRoLCAwLCAwKTtcbiAgICAgICAgc2VsZi5pc1Nob3dZR3JpZCA9IGlzU2hvd1lHcmlkO1xuICAgICAgICBtYWluLnNlbGVjdCgnZy5tYWluLmF4aXMubGFuZScpLmNhbGwoeUF4aXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbc2VsZi53aWR0aCwgc2VsZi5oZWlnaHRdO1xuICAgICAgICBzZWxmLndpZHRoID0gcGFyc2VJbnQod2lkdGgpIHx8IHNlbGYud2lkdGg7XG4gICAgICAgIHNlbGYuaGVpZ2h0ID0gcGFyc2VJbnQoaGVpZ2h0KSB8fCBzZWxmLmhlaWdodDtcbiAgICAgICAgYXV0b3Jlc2l6ZShmYWxzZSk7XG4gICAgICAgIHJlc2l6ZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YmxhbmVzKG5ld1N1YmxhbmVzKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNlbGYuc3VibGFuZXM7XG4gICAgICAgIHNlbGYuc3VibGFuZXMgPSBuZXdTdWJsYW5lcztcbiAgICAgICAgcmVkcmF3KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkSXRlbXM6IGFkZEl0ZW1zLFxuICAgICAgICBhdXRvcmVzaXplOiBhdXRvcmVzaXplLFxuICAgICAgICBlbmFibGVab29tOiBlbmFibGVab29tLFxuICAgICAgICBjaGFydDogZnVuY3Rpb24oKSB7IHJldHVybiBtYWluIH0sXG4gICAgICAgIGl0ZW1zOiBpdGVtcyxcbiAgICAgICAgbGFuZXM6IGxhbmVzLFxuICAgICAgICBtYXJnaW46IG1hcmdpbixcbiAgICAgICAgc2hvd0xhbmVMYWJlbDogc2hvd0xhbmVMYWJlbCxcbiAgICAgICAgc2hvd1Rvb2x0aXA6IHNob3dUb29sdGlwLFxuICAgICAgICBzaG93WEdyaWQ6IHNob3dYR3JpZCxcbiAgICAgICAgc2hvd1lHcmlkOiBzaG93WUdyaWQsXG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIHN1YmxhbmVzOiBzdWJsYW5lcyxcbiAgICAgICAgc3ZnOiBmdW5jdGlvbigpIHsgcmV0dXJuIGNoYXJ0IH0sXG4gICAgICAgIHJlZHJhdzogcmVkcmF3LFxuICAgICAgICByZW5kZXJUbzogZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLnJlbmRlclRvIH0sXG4gICAgICAgIHJlc2l6ZTogcmVzaXplLFxuICAgICAgICB4QXhpczogZnVuY3Rpb24oKSB7IHJldHVybiB4QXhpcyB9LFxuICAgICAgICB4U2NhbGU6IGZ1bmN0aW9uKCkgeyByZXR1cm4geFNjYWxlIH0sXG4gICAgICAgIHlTY2FsZTogZnVuY3Rpb24oKSB7IHJldHVybiB5U2NhbGUgfSxcbiAgICAgICAgeUF4aXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4geUF4aXMgfSxcbiAgICAgICAgem9vbTogZnVuY3Rpb24oKSB7IHJldHVybiB6b29tIH0sXG4gICAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
